---
title: "Stats - Ripening"
author: "Mar Garcia-Aloy"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    toc: true
    number_sections: false
    toc_float: true
---

```{r startpoint, include = FALSE}
startpoint <- Sys.time()
knitr::opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE)
```

In this document we do an analysis of untargeted lipidomics data from grape samples collected at different maturation stages.

# Libraries

```{r, message=FALSE, warning=FALSE}
library(readxl)
library(pander)
library(RColorBrewer)
library(pls)
library(pheatmap)
library(ggplot2)
library(gridExtra)
```

# Colours 

```{r, echo = TRUE}
col_cmps <- c(
  "#E41A1C", "pink", "#974661", "#4A72A6", "#3E8E93", "#48A462", 
  "#5D995D", "#90CC90", "#7E6E85", "#A35390", "#D16948", "#FF7F00", "#FFB716", 
  "#FFF02D", "#E1C62F", "#B97B2A", "#B97B2A", "#ea890b", 
  "#B75F49", "#DB728C", "#EC83BA", "#C28EA9", "#999999", "grey",
  "#FFFFBF50", "tomato", "tomato", "black", "white")
names(col_cmps) <- c(
  "FFA", "FFA_O", "LPA", "LPE", "LPG", "LPI", 
  "PA", "mPA", "PC", "PE", "PG", "PI", "PS", 
  "CAR", "MAG", "CER", "CERhex", "pCERhex", 
  "DAG", "DGDG", "Lyso_PC", "MGDG", "TAG", "unk_NL325", 
  "X", "others", "non_FA", "unknown", "IS")
```


# Data import

```{r echo=TRUE}
brix <- read_excel("../target/data/Grape_Brix_Datafile.xlsx")
brix <- brix[order(brix$data, brix$Replicate), ]

data <- read.csv("output/data_maturation.csv", row.names = 1)
data <- data[!grepl("rw|dl", rownames(data)),]

#cmps.q <- read.csv("output/data_maturation.csv")
cmps <- read.csv("compounds.csv")
cmps$id <- cmps$compound
cmps$id <- gsub(")", "", cmps$id)
cmps$id <- gsub("\\(", "_", cmps$id)
cmps$id <- gsub("/", "_", cmps$id)
cmps$id <- gsub(":", ".", cmps$id)
cmps$id <- gsub("^_", "X_", cmps$id)

cmps <- cmps[cmps$id %in% colnames(data), ]
cmps <- cmps[!duplicated(cmps$compound),]
cmps <- cmps[order(factor(cmps$id, levels = colnames(data))),]
all(colnames(data) == cmps$id)
#cmps$class[grepl("d", cmps$compound)] <- "IS"
#cmps$class[cmps$compound %in% c("Disaccharide", "Kaempferol glucoside", 
#                                "Malic acid")] <- "others"
#cmps$class <- factor(cmps$class, levels = c(
#  "FFA", "FFA_O", "CERhex", "pCERhex", "PA", "mPA", "Lyso_PC", "PC", "PE", 
#  "PG", "PI", "PS", "MGDG", "DGDG", "DAG", "TAG", "unk_NL325", "others", 
#  "unknown", "IS"))

#data <- data[order(rownames(data)),]
#cmps.q <- cmps.q[colSums(data, na.rm = T) > 0]
#cmps <- cmps[colSums(data, na.rm = T) > 0,]
#data <- data[, colSums(data, na.rm = T) > 0]
class <- gsub("_.*", "", rownames(data))
class[grep("QC", class)] <-"QC"
```

The dataset contains information about n=`r ncol(data)` compounds in n=`r nrow(data)` samples of the following classes: `r paste0(aggregate(class, list(class), function(x){sum(class == x)})[,1], " (n=", aggregate(class, list(class), function(x){sum(class == x)})[,2], ")", collapse = "; ")`.   
The subsequent analyses will be applied only to study samples. Therefore, below `QC` samples are excluded from the dataset:

```{r}
#data <- data[grep("Pt", rownames(data)),]
#class <- gsub("_.*", "", rownames(data))
```

The samples used in this analysis are: 

```{r}
pandoc.table(as.data.frame(rownames(data)[order(rownames(data))]), 
             style = "rmarkdown", caption = "Samples used in this analysis")
```


Identified compounds are from the following classes:

```{r}
#pandoc.table(as.data.frame(table(cmps$class)), style = "rmarkdown")
```

# Exploratory analysis

```{r, eval=FALSE}
tmp <- colMeans(data)
quanti <- aggregate(tmp, list(cmps$class), function(x){sum(x, na.rm=T)})
quanti <- quanti[!quanti$Group.1 %in% c("IS"), ]
slices <- quanti$x
lbls <- quanti$Group.1
pie(slices, lbls, col = col_class_cmps[as.character(lbls)])

tmp <- colMeans(data)
quanti <- aggregate(tmp, list(cmps$class), function(x){sum(x, na.rm=T)})
quanti <- quanti[!quanti$Group.1 %in% c("IS", "unknown", "others"), ]
slices <- quanti$x
lbls <- quanti$Group.1
pie(slices, lbls, col = col_class_cmps[as.character(lbls)])
```

From the pie charts it can bee seen that the most abundant lipids are `TAGs`, followed by `PC` and, with a lesser extent `DAGs`. 

Principal component analysis (PCA) is performed on log-transformed and Pareto-scaled abundances.

```{r pca, fig.width=10}
sum(is.na(data)) # number of missing values
dt <- log10(data)
scaling.pareto <- BioMark::scalefun(sc.p="pareto")
dt <- data.frame(scaling.pareto(dt))
pca <- prcomp(dt, center = FALSE, scale. = FALSE)

par(mfrow = c(1, 2), mar = c(4, 4, 2, 0.5))
pca_s <- data.frame(pca$x)
plot(pca_s$PC1, pca_s$PC2, 
     xlab = paste0("PC1 (", sprintf("%.1f", 
                                    summary(pca)$importance[2,1]*100), "%)"), 
     ylab = paste0("PC2 (", sprintf("%.1f", 
                                    summary(pca)$importance[2,2]*100), "%)"), 
     main = "Exploratory PCA", col = "white", bty = "l")
text(pca_s$PC1, pca_s$PC2, rownames(data))
abline(v = 0, h = 0, lty = 2, col = "grey")
pca_l <- data.frame(pca$rotation)
plot(pca_l$PC1, pca_l$PC2, xlab = "PC1", ylab = "PC2", bty = "l")
abline(v = 0, h = 0, lty = 2, col = "grey")

class_col <- c(colorRampPalette(brewer.pal(10, "PiYG"))(13), "grey")
names(class_col) <- levels(as.factor(class))
plot(pca_s$PC1, pca_s$PC2, 
     xlab = paste0("PC1 (", sprintf("%.1f", 
                                    summary(pca)$importance[2,1]*100), "%)"), 
     ylab = paste0("PC2 (", sprintf("%.1f", 
                                    summary(pca)$importance[2,2]*100), "%)"), 
     col = class_col[class], bty = "l", pch = 16)
text(pca_s$PC1, pca_s$PC2, gsub("_.*", "", gsub("Pt", "", rownames(data))), 
     pos = 1, cex = 0.6)
abline(v = 0, h = 0, lty = 2, col = "grey")
plot(pca_l$PC1, pca_l$PC2, xlab = "PC1", ylab = "PC2", bty = "l", 
     col = col_cmps[cmps$class], pch = 16)
abline(v = 0, h = 0, lty = 2, col = "grey")
text(pca_l$PC1, pca_l$PC2, cmps$compound, pos = 1, cex = 0.6)
```


Visual inspection of the PCA score shows a certain degree of separation between the first and second half of samples along the first component (accounting for `r round(summary(pca)$importance[2,1]*100, 1)`% of the total variance explained).


```{r pca2, fig.height=7, fig.width=20}
par(mfrow = c(1, 2))

biplot(pca)

plot(pca_s$PC1, pca_s$PC2, 
     xlab = paste0("PC1 (", sprintf("%.1f", 
                                    summary(pca)$importance[2,1]*100), "%)"), 
     ylab = paste0("PC2 (", sprintf("%.1f", 
                                    summary(pca)$importance[2,2]*100), "%)"), 
     col = class_col[class], bty = "l", pch = 16)
grid()
abline(v = 0, h = 0, lty = 2, col = "grey", lwd = 2)
text(pca_s$PC1, pca_s$PC2, gsub("_.*", "", gsub("Pt", "", rownames(data))), 
     pos = 1, cex = 0.6)
text(pca_l$PC1*min(range(pca_s$PC1) / range(pca_l$PC1)), 
     pca_l$PC2*min(range(pca_s$PC2) / range(pca_l$PC2)), 
     cmps$compound, cex = 0.5, col = col_cmps[cmps$class])
```

# Associations of brix degree with the lipidomic profile of samples: PLS

First of all we fit a model with all samples.

```{r}
data <- data[!grepl("QC", rownames(data)),]
data <- data[order(rownames(data)),]
brix <- brix[order(brix$data, brix$Replicate),]
dt <- log10(data)
set.seed(123)
model <- plsr(brix$Brix ~ ., data = dt, scale = TRUE, center = TRUE, 
              validation = "CV", ncomp = 10)
summary(model)
validationplot(model)
validationplot(model, val.type = "R2")
R2(model)
nc <- selectNcomp(model, plot = TRUE)
```

The algorithm suggests that the best number of components is `r nc`.

```{r}
pd <- plot(model, ncomp = nc, line = T, 
           col = class_col[gsub("_.*", "", rownames(data))], pch = 16)
text(brix$Brix, pd[,"predicted"], 
     gsub("Pt", "", gsub("_.*", "", rownames(data))), cex = 0.5, pos = 1)
```

The correlation between measured and predicted brix degree is, `r sprintf("%.3f", cor(brix$Brix, predict(model, dt, ncomp = nc)))`.

## Validation

In order to verify that the model is not overfitted, below we are going to repeat the procedure, but this time building the model with 2/3 of the samples and predicting the brix values with the other 1/3 of samples. Assignation of samples to train or test set is doing randomly and the process is repeated 1000 times. We will check the distribution on the optimal number of components and R2 values along all generated models.

```{r validation}
nsubmod <- 10#1000
N.vals <- c()
R2.vals <- c()
R2.rndm <- c()
set.seed(123)
seeds <- sample(seq(1e6), nsubmod, replace = FALSE)
set.seed(456)
rndm <- sample(seq(1e6), nsubmod, replace = FALSE)
for(i in seq(length(seeds))){
  set.seed(seeds[i])
  idx <- sample(seq(nrow(dt)), 40, replace = FALSE)
  set.seed(rndm[i])
  x.rndm <- brix$Brix[sample(seq(length(brix$Brix)), 
                             length(brix$Brix), replace = FALSE)]
  dt_train <- cbind(brix = brix$Brix[idx], dt[idx,])
  dt_test <- cbind(brix = brix$Brix[!seq(nrow(dt)) %in% idx],
                   dt[!seq(nrow(dt)) %in% idx,])
  dt_train_r <- cbind(brix = x.rndm[idx], dt[idx,])
  dt_test_r <- cbind(brix = x.rndm[!seq(nrow(dt)) %in% idx],
                     dt[!seq(nrow(dt)) %in% idx,])
  mdl <- plsr(brix ~ ., data = dt_train, scale = TRUE, center = TRUE, 
              validation = "CV", ncomp = 10)
  mdl_r <- plsr(brix ~ ., data = dt_train_r, scale = TRUE, center = TRUE, 
                validation = "CV", ncomp = 10)
  N.vals <- c(N.vals, selectNcomp(mdl))
  R2.vals <- c(R2.vals, 
               R2(mdl, estimate = "test", newdata = dt_test
               )$val[selectNcomp(mdl)+1])
  
  R2.rndm <- c(R2.rndm, 
               R2(mdl_r, estimate = "test", newdata = dt_test_r
               )$val[selectNcomp(mdl_r)+1])
}
barplot(table(N.vals))
table(N.vals)
prop.table(table(N.vals))*100
boxplot(c(R2.vals, R2.rndm) ~ c(rep(1, nsubmod), rep(2, nsubmod)), 
        col = "white", ylim = c(-1, 1), ylab = "R2", xlab = "", xaxt = "n", 
        outline = FALSE)
axis(1, at = seq(2), labels = c("true Y", "random Y"))
stripchart(c(R2.vals, R2.rndm) ~ c(rep(1, nsubmod), rep(2, nsubmod)),     
           method = "jitter", vertical = TRUE, add = TRUE,
           pch = 19, col = c(4, "grey"), cex = 0.4)
```

R2 values of the generated sub-models have a median value `r sprintf("%.3f", median(R2.vals))`, a considerably higher value than the one obtained with the random models (median `r sprintf("%.3f", median(R2.rndm))`).

## Associated classes of comopunds with brix degree

To get a general overview of which types of compounds are associated with the brix degree, we check the distribution of regression coefficients in the model built with all experimental data according to compound class, considering that those classes with a higher proportion in the first quartile will be those compounds with a decreasing behaviour over maturation process, whereas those compound classes with higher proportions in the fourth quartile will be those compounds with a direct association with the brix degree / date (i.e., maturation process).

```{r plots, message=FALSE}
p <- list()
for(i in seq(ncol(data))){
  dt <- data.frame(
    value = data[,i],
    class = gsub("_.*", "", rownames(data)),
    brix = brix$Brix
  )
  dt <- dt[order(dt$class),]
  dt$na <- is.na(dt$value)
  dt$value[is.na(dt$value)] <- 1
  
  
  p[[i]] <- ggplot(data = dt, aes(x = brix, y = value)) + 
    geom_point(aes(color = gsub("_.*", "", rownames(data)), 
                   pch = na), size = 2) +
    ggtitle(cmps$compound[i]) +
    xlab("") + ylab("") + theme_bw()+ theme(legend.position = "none") +
    scale_y_log10() +
    scale_shape_manual(values = c(19,1)) +
    geom_smooth(method = "lm")
  
}
ggsave(
  filename = "output/ripening_trends.pdf",
  plot = marrangeGrob(p, nrow = 4, ncol = 4),
  width = 15, height = 12
)

tmp <- data.frame(
  RC = coef(model, ncomp = 2),
  class = cmps$class
)
colnames(tmp)[1] <- "RC"
tmp$quantile <- dplyr::ntile(tmp$RC, 4)
tmp$class <- droplevels(factor(tmp$class))

pandoc.table(table(tmp$class, tmp$quantile), style = "rmarkdown", split.table = Inf)
tmp2 <- prop.table(table(tmp$class, tmp$quantile), 1)*100
pandoc.table(round(tmp2), style = "rmarkdown", split.table = Inf)

tmp2 <- cbind(tmp2[,1],
              tmp2[, 2] + tmp2[,3],
              tmp2[, 4])
colnames(tmp2) <- c("Q1", "Q2-Q3", "Q4")
```

The following heatmap shows the quartile distribution of regression coefficients by compound class. Since the clases of interest will be the ones with higher proportion of compunds in the first and fourth quartile, we have grouped together Q2 and Q3. Proportions of compounds in different quartiles are depicted with a color scale where red represents the categories with higher proportions and blue represents the lowest ones.

```{r}
pheatmap(tmp2, cluster_cols = F, cutree_rows = 1, 
         color = colorRampPalette(brewer.pal(n = 9, name ="Blues"))(100))
pheatmap(tmp2[,-2], cluster_cols = F, cutree_rows = 3, 
         color = colorRampPalette(brewer.pal(n = 9, name ="Blues"))(100),
         cellwidth = 50, fontsize = 8)
```

We can see three row clusters: one with those compound classes with higher proportions within the Q1 and the other one with those compound classes with higher proportions within the Q4. Among these, we could say that classes `CERhex`, `PA`, `MGDG` and `DGDG` seem to be the ones with higher proportions of specific compounds inversely related with brix degree (i.e., in general, their levels drop as brix increases), whereas `FFA`, `mPA` and `PC` would be the ones with higher proportion of specific compounds directly related with brix degree.
Below we plot the behaviour of specific compounds of mentioned classes. Color scale is proportional to the corresponding regression coefficient.

```{r, fig.width=20, fig.height=10, eval=FALSE}
dt <- log10(data)

plt.cls <- function(cls, clr, dcrs){
  idx <- which(cmps$class == cls)
  pal <- colorRampPalette(brewer.pal(9, clr))
  i <- 1
  j <- order(tmp$RC[idx], decreasing = dcrs)[i]
  plot(brix$Brix, scale(dt[,idx][j]), xlab = "", ylab = "", 
       main = cls, bty = "l", 
       col = pal(length(idx))[i], 
       ylim = c(min(scale(dt[,idx])), max(scale(dt[,idx]))))
  abline(lm(scale(dt[,idx[j]])~brix$Brix), 
         col = pal(length(idx))[i])
  title(xlab = "°Brix", line = 2, cex.lab = 1.2, ylab = "scaled value")
  
  for(i in 2:length(idx)){
    j <- order(tmp$RC[idx], decreasing = dcrs)[i]
    points(brix$Brix, scale(dt[,idx[j]]), 
           col = pal(length(idx))[i])
    abline(lm(scale(dt[,idx[j]])~brix$Brix), 
           col = pal(length(idx))[i])
  }}
par(mfrow = c(2, 4), mar = c(4, 3, 2, 0.5))
plt.cls(cls = "CERhex", clr = "Reds", dcrs = T)
plt.cls(cls = "PA", clr = "Reds", dcrs = T)
plt.cls(cls = "MGDG", clr = "Reds", dcrs = T)
plt.cls(cls = "DGDG", clr = "Reds", dcrs = T)
plt.cls(cls = "FFA", clr = "Greens", dcrs = F)
plt.cls(cls = "mPA", clr = "Greens", dcrs = F)
plt.cls(cls = "PC", clr = "Greens", dcrs = F)
```

[**Since in this case in general not all compounds of the same class have the same behavior, maybe try to check if these differences could be related with the length of FA chains, number of insaturations, or wherever other characteristic of lipid composition that could have a biological explanation. Still have to thing how to do it.**]{style="color:red"}

# Correlations

```{r}
c <- apply(data, 2, function(x) cor.test(log10(brix$Brix), log10(x))$estimate)
p <- apply(data, 2, function(x) cor.test(log10(brix$Brix), log10(x))$p.value)
padj <- p.adjust(p, "BH")
sum(padj < 0.05)
res <- data.frame(cbind(c, p, padj, cmps$class))
colnames(res) <- c("cor", "pval", "padj", "class")
res$cor <- as.numeric(res$cor)
res$pval <- as.numeric(res$pval)
res$padj <- as.numeric(res$padj)
res$beh <- "-"
res$beh[res$padj > 0.05] <- "ns"
res$beh[res$padj < 0.05 & res$cor < 0] <- "down"
res$beh[res$padj < 0.05 & res$cor > 0] <- "up"
table(res$class, res$beh)
round(prop.table(table(res$class, res$beh), margin = 1)*100)
rownames(res)[res$beh == "up"]
rownames(res)[res$beh == "down"]
```

```{r, fig.height=4*ceiling(sum(padj < 0.05)/3), fig.width=15}
par(mfrow = c(ceiling(sum(padj < 0.05)/3), 3))
for(x in c("up", "down")){
  idx <- which(res$beh == x)
  for(i in seq(length(idx))){
    plot(brix$Brix, data[,idx[i]], xlab = "º Brix", ylab = "intensity", 
         main = paste0(cmps$compound[cmps$id == colnames(data)[idx[i]]],
                       "\n cor = ", 
                       sprintf("%.3f", as.numeric(res$cor[idx[i]]))), 
         col = class_col[gsub("_.*", "", rownames(data))], pch = 16)
    abline(lm(data[,idx[i]]~brix$Brix), col = "grey")
  }
}
```

```{r}
pheatmap(cor(log10(data[,padj < 0.05])), cutree_cols = 3, cutree_rows = 3)
```

# Session information

```{r session}
Sys.time()-startpoint
devtools::session_info()
```


