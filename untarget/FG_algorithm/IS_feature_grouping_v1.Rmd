---
title: "Feature grouping (version 1)"
output: word_document
---


# Preliminaries

In this document I'm going to show how works the feature grouping algorithm on a simple dataset. This dataset consists of 6 samples, two replicates of each of the following sample types:  

- solvent (composed only by solvent)  
- blank (empty samples submitted to the same preparation procedure as study samples, i.e., they just include the IS)  
- STDmix (composed by a mix of 77 known compounds, but not submitted to the standard preparation procedure, i.e. they do not include the IS)  

XCMS processing of this dataset is already done in both polarities. The only difference in the processing is that for NEG polarity I've retained those features that contain at least 5 peaks with intensity \>= 1e5 counts, whereas for POS polarity the intensity threshold has been 2.5e5 counts.

Below, I load the data and plot the distribution of samples and features through a PCA:

```{r pca, echo=FALSE, message=FALSE, warning=FALSE}
library(xcms)
load("data/RData/IS_data_XCMS_POS.RData")
xdata_pos <- xdata
load("data/RData/IS_data_XCMS_NEG.RData")
xdata_neg <- xdata
rm(xdata)

ids_neg <- read.csv("data/IS_identifications_NEG.csv", row.names = 1)
ids_pos <- read.csv("data/IS_identifications_POS.csv", row.names = 1)
ids <- rbind(ids_neg, ids_pos)

pca_xdata <- function(x){
  data <- featureValues(x, method = "sum", value = "into")
  set.seed(123)
  data <- t(imputeRowMinRand(data, method = "from_to",
                             min_fraction = 1/100,
                             min_fraction_from = 1/1000
  ))
  dt <- log10(data)
  scaling.pareto <- BioMark::scalefun(sc.p="pareto")
  dt <- data.frame(scaling.pareto(dt))
  pca <- prcomp(dt, center = FALSE, scale. = FALSE)
  pca
}

par(mfrow = c(2, 2), mar = c(1, 1, 2, 1))

pca_pos <- data.frame(pca_xdata(xdata_pos)$x)
tmp_x <- max(abs(min(pca_pos$PC1)), max(pca_pos$PC1))
tmp_y <- max(abs(min(pca_pos$PC2)), max(pca_pos$PC2))
plot(pca_pos$PC1, pca_pos$PC2, 
     col = as.numeric(factor(xdata_pos$tissue)) + 1, pch = 16,
     main = "POS", axes = FALSE, 
     xlim = c(-tmp_x, tmp_x), ylim = c(-tmp_y, tmp_y))
grid()
abline(v = 0, h = 0)
legend("topleft", col = 2:4, legend = levels(factor(xdata_pos$tissue)), 
       pch = 16, bty = "n")

pca_neg <- data.frame(pca_xdata(xdata_neg)$x)
tmp_x <- max(abs(min(pca_neg$PC1)), max(pca_neg$PC1))
tmp_y <- max(abs(min(pca_neg$PC2)), max(pca_neg$PC2))
plot(pca_neg$PC1, pca_neg$PC2, 
     col = as.numeric(factor(xdata_neg$tissue)) + 1, pch = 16,
     main = "NEG", axes = FALSE, 
     xlim = c(-tmp_x, tmp_x), ylim = c(-tmp_y, tmp_y))
grid()
abline(v = 0, h = 0)

pca_pos <- data.frame(pca_xdata(xdata_pos)$rotation)
dt <- featureValues(xdata_pos, method = "sum", value = "into")
dt[is.na(dt)] <- 0
tmp <- data.frame(featureDefinitions(xdata_pos))
tmp$mean_blank <- rowMeans(dt[,xdata_pos$tissue == "blank"])
tmp$mean_blank_no <- rowMeans(dt[,xdata_pos$tissue != "blank"])
tmp$blank_prop <- tmp$mean_blank / tmp$mean_blank_no
tmp$blank_prop[tmp$blank_prop == "Inf"] <- tmp$mean_blank[tmp$blank_prop == "Inf"]
tmp$mean_std <- rowMeans(dt[,xdata_pos$tissue == "STDmix"])
tmp$mean_std_no <- rowMeans(dt[,xdata_pos$tissue != "STDmix"])
tmp$std_prop <- tmp$mean_std / tmp$mean_std_no
tmp$std_prop[tmp$std_prop == "Inf"] <- tmp$mean_std[tmp$std_prop == "Inf"]
tmp$mean_solv <- rowMeans(dt[,xdata_pos$tissue == "solv"])
tmp$mean_solv_no <- rowMeans(dt[,xdata_pos$tissue != "solv"])
tmp$solv_prop <- tmp$mean_solv / tmp$mean_solv_no
tmp$solv_prop[tmp$solv_prop == "Inf"] <- tmp$mean_solv[tmp$solv_prop == "Inf"]
tmp$color <- 1
tmp$color[tmp$npeaks == 2 & tmp$solv == 0 & tmp$blank == 2 & tmp$STDmix == 0] <- 2
tmp$color[tmp$npeaks == 2 & tmp$solv == 2 & tmp$blank == 0 & tmp$STDmix == 0] <- 3
tmp$color[tmp$npeaks == 2 & tmp$solv == 0 & tmp$blank == 0 & tmp$STDmix == 2] <- 4
tmp$col2 <- "grey"
tmp$col2[tmp$npeaks == 2 & tmp$solv == 0 & tmp$blank == 2 & tmp$STDmix == 0 & 
           !grepl("Unknown", ids_pos$compound) &
           !grepl("Background", ids_pos$compound)] <- "black"
tmp$color[tmp$color == 2 & tmp$blank_prop < 300] <- "#E41A1C50"
tmp$color[tmp$color == 4 & tmp$std_prop < 300] <- "#377EB850"
#tmp$color[tmp$color == 3 & tmp$solv_prop < 300] <- "#4DAF4A50"
tmp_x <- max(abs(min(pca_pos$PC1)), max(pca_pos$PC1))
tmp_y <- max(abs(min(pca_pos$PC2)), max(pca_pos$PC2))
plot(pca_pos$PC1, pca_pos$PC2, 
     bg = tmp$color, col = tmp$col2, pch = 21, lwd = 0.1, axes = FALSE, 
     xlim = c(-tmp_x, tmp_x), ylim = c(-tmp_y, tmp_y))
grid()
abline(v = 0, h = 0)

pca_neg <- data.frame(pca_xdata(xdata_neg)$rotation)
dt <- featureValues(xdata_neg, method = "sum", value = "into")
dt[is.na(dt)] <- 0
tmp <- data.frame(featureDefinitions(xdata_neg))
tmp$mean_blank <- rowMeans(dt[,xdata_neg$tissue == "blank"])
tmp$mean_blank_no <- rowMeans(dt[,xdata_neg$tissue != "blank"])
tmp$blank_prop <- tmp$mean_blank / tmp$mean_blank_no
tmp$blank_prop[tmp$blank_prop == "Inf"] <- tmp$mean_blank[tmp$blank_prop == "Inf"]
tmp$mean_std <- rowMeans(dt[,xdata_neg$tissue == "STDmix"])
tmp$mean_std_no <- rowMeans(dt[,xdata_neg$tissue != "STDmix"])
tmp$std_prop <- tmp$mean_std / tmp$mean_std_no
tmp$std_prop[tmp$std_prop == "Inf"] <- tmp$mean_std[tmp$std_prop == "Inf"]
tmp$mean_solv <- rowMeans(dt[,xdata_neg$tissue == "solv"])
tmp$mean_solv_no <- rowMeans(dt[,xdata_neg$tissue != "solv"])
tmp$solv_prop <- tmp$mean_solv / tmp$mean_solv_no
tmp$solv_prop[tmp$solv_prop == "Inf"] <- tmp$mean_solv[tmp$solv_prop == "Inf"]
tmp$color <- 1
tmp$color[tmp$npeaks == 2 & tmp$solv == 0 & tmp$blank == 2 & tmp$STDmix == 0] <- 2
tmp$color[tmp$npeaks == 2 & tmp$solv == 2 & tmp$blank == 0 & tmp$STDmix == 0] <- 3
tmp$color[tmp$npeaks == 2 & tmp$solv == 0 & tmp$blank == 0 & tmp$STDmix == 2] <- 4
tmp$col2 <- "grey"
tmp$col2[tmp$npeaks == 2 & tmp$solv == 0 & tmp$blank == 2 & tmp$STDmix == 0 & 
           !grepl("Unknown", ids_neg$compound) &
           !grepl("Background", ids_neg$compound)] <- "black"
tmp$color[tmp$color == 2 & tmp$blank_prop < 300] <- "#E41A1C50"
tmp$color[tmp$color == 4 & tmp$std_prop < 300] <- "#377EB850"
#tmp$color[tmp$color == 3 & tmp$solv_prop < 300] <- "#4DAF4A50"
tmp_x <- max(abs(min(pca_neg$PC1)), max(pca_neg$PC1))
tmp_y <- max(abs(min(pca_neg$PC2)), max(pca_neg$PC2))
plot(pca_neg$PC1, pca_neg$PC2, 
     bg = tmp$color, col = tmp$col2, pch = 21, lwd = 0.1, axes = FALSE, 
     xlim = c(-tmp_x, tmp_x), ylim = c(-tmp_y, tmp_y))
grid()
abline(v = 0, h = 0)
rm(list=ls())
```

As already mentioned in the report from 16-March-2021, the figure shows the score (upper side) and loading (bottom side) plots of PCA from positive (left side) and negative (right side) data. Samples in the score plots are colored according to their class, and features in the loading plots are colored according to their specificity for a certain sample class (i.e. they are colored when they have only been detected in one type of sample).   
Therefore, the initial hypothesis is that red features should correspond to signals derived from internal standards and blue features to signals derived from standards included in the STDmix samples.  
The intensity of feature colors in the loadings plot (with the exception of features characteristic of solvent samples) indicates if the mean intensity for a specific class is at least 300 times higher in comparison of the mean intensity within the other samples not corresponding to that class.  
Additionally, for red-colored features (i.e., the ones characteristic of blank samples) the black border line indicates that are identified features corresponding to an IS (done in a manual way, check report from 16-March-2021), whereas the gray border line is used for features assigned to unknown and background ions.  


# Feature grouping

At this point, I want to automatically group those features representing ions (isotopes, adducts, fragments) of the same compound (remember that ESI usually generates different ions from the same original compound, which are then reported with different m/z values).  
Features from the same originating compound inherit its characteristics, including its retention time, abundance and peak shape. Therefore, those co-eluting features with high intensity and peak shape correlations should be grouped together since probably are coming from the same compound.   

In this example I perform first a initial grouping of features based on similar retention time. Next I further refine these feature groups by requiring similarity of feature values across samples, and finally I additionally refine the feature groups by also requiring similarity of peak shapes.  
Let's do the feature grouping of the first ion as a case example. The idea is to take 1 feature and check which other features from the dataset should be grouped together with the first one. This first feature grouping step has to be done separately for each ionization mode, since the peak shape correlation will not be exactly the same for the same compound in each ionization mode:

```{r}
# load the data in positive ionization mode:
load("data/RData/IS_data_XCMS_POS.RData")
```

I'll start the feature grouping with the most intensity ion. Therefore, I need to know which is the ion with the highest intensity:

```{r}
# get the matrix of feature values (using the peak area = "into"):
data <- featureValues(xdata, method = "sum", value = "into")
data[is.na(data)] <- 0 # replace missing values by 0

# get the matrix with the feature definitions (i.e. the mz and rt ranges, among other information):
features <- data.frame(featureDefinitions(xdata))

# calculate the mean(intensity) of each feature according the type of sample:
features$mean_solv <- rowMeans(data[,xdata$tissue == "solv"])
features$mean_blank <- rowMeans(data[,xdata$tissue == "blank"])
features$mean_STDmix <- rowMeans(data[,xdata$tissue == "STDmix"])

# get the maximum value of mean(intensity) among the 3 sample classes:
features$mean_max <- apply(features[,c("mean_solv", "mean_blank", "mean_STDmix")], 1, max)

# order the features according the "mean_max" value in from the highest one:
features <- features[order(features$mean_max, decreasing = T), ]

# get the features particular of blank samples:
features <- features[features$npeaks == 2 & features$blank == 2 & 
                       features$solv == 0 & features$STDmix == 0, ]
```

Let's start with the first feature (i.e., the feature with the highest intensity among blank samples):

```{r}
y <- 1
features[y,]
```

This feature will be called `feature "y"`.  
First of all, I'll take those features that are co-eluting with `feature "y"`:

```{r}
y.features <- features[(features$rtmed > (features$rtmed[y] - 10)) & 
                         ( features$rtmed < (features$rtmed[y] + 10)), ]
y.features[,c("mzmed", "rtmed", "mean_max")]
```

There are 7 features co-eluting with `feature "y"`.

Then, I'll calculate the intensity correlation between `feature "y"` and these co-eluting features:

```{r}
y.data <- data[rownames(data) %in% rownames(y.features), ]
y.cor <- cor(t(y.data), y.data[rownames(features)[y],])
y.features <- merge(y.features,y.cor, by = "row.names")
colnames(y.features)[ncol(y.features)] <- "corr_int"
rownames(y.features) <- y.features$Row.names
y.features <- y.features[,-1]
```

```{r, echo=FALSE}
y.features2 <- y.features
y.features2$mzmed <- sprintf("%.4f", round(y.features2$mzmed, 4))
y.features2$rtmed <- sprintf("%.2f", round(y.features2$rtmed/60, 2))
y.features2$mean_max <- round(y.features$mean_max)
y.features2$corr_int <- sprintf("%.2f", round(y.features$corr_int, 2))
library(DT)
datatable(y.features2[,c("mzmed", "rtmed", "mean_max", "corr_int")], options = list(dom = 't', pageLength = nrow(y.features2))) %>% formatStyle(columns = "corr_int", backgroundColor = styleInterval(0.7,c("#FB717E","#89EC6A")))
```

All co-eluting features present a high intensity correlation with `feature "y"`.  

The next step is to calculate the peak shape correlation between `feature "y"` and the co-eluting features with high intensity correlation:

```{r}
y.features <- y.features[y.features$corr_int > 0.7, ]

# get the sample with the highest intensity for feature "y":
y.xdata <- filterFile(xdata, which.max(data[rownames(features)[y],]))

# extract the chromatogram of feature "y":
y.chr <- chromatogram(y.xdata,
                      mz = features$mzmed[y] + 0.01 * c(-1, 1),
                      rt = features$rtmed[y] + 10 * c(-1,1),
                      aggregationFun = "max")

# for each of the other selected features, extract the corresponding chromatogram and correlate it with the EIC of feature "y":
y.cor <- c()
for(i in seq(nrow(y.features))){
  y.chr2 <- chromatogram(y.xdata,
                         mz = y.features$mzmed[i] + 0.01 * c(-1, 1),
                         rt = y.features$rtmed[i] + 10 * c(-1,1),
                         aggregationFun = "max")
  y.cor <- c(y.cor, correlate(y.chr[[1]], y.chr2[[1]]))
  names(y.cor)[length(y.cor)] <- rownames(y.features)[i]
}
y.cor[is.na(y.cor)] <- 0
y.features <- merge(y.features,y.cor, by = "row.names")
colnames(y.features)[ncol(y.features)] <- "corr_ps"
rownames(y.features) <- y.features$Row.names
y.features <- y.features[,-1]
```

```{r, echo=FALSE}
y.features2 <- y.features
y.features2$mzmed <- sprintf("%.4f", round(y.features2$mzmed, 4))
y.features2$rtmed <- sprintf("%.2f", round(y.features2$rtmed/60, 2))
y.features2$mean_max <- round(y.features$mean_max)
y.features2$corr_int <- sprintf("%.2f", round(y.features$corr_int, 2))
y.features2$corr_ps <- sprintf("%.2f", round(y.features$corr_ps, 2))
datatable(y.features2[,c("mzmed", "rtmed", "mean_max", "corr_int", "corr_ps")], options = list(dom = 't', pageLength = nrow(y.features2))) %>% formatStyle(columns = "corr_ps", backgroundColor = styleInterval(0.7,c("#FB717E","#89EC6A")))
```

Here we can see that not all features present a high peak shape correlation wih `feature "y"`.   
Let's visualize it:

```{r, echo = FALSE}
plot(rtime(y.chr[[1]]), intensity(y.chr[[1]])/max(intensity(y.chr[[1]]), na.rm = T), type = "l", xlab = "RT", ylab = "Relative intensity")
for(i in seq(nrow(y.features))){
  y.chr2 <- chromatogram(y.xdata,
                         mz = y.features$mzmed[i] + 0.01 * c(-1, 1),
                         rt = y.features$rtmed[i] + 10 * c(-1,1),
                         aggregationFun = "max")
  points(rtime(y.chr2[[1]]), intensity(y.chr2[[1]])/max(intensity(y.chr2[[1]]), na.rm = T), type = "l", col = i)
}
legend("topright", legend = y.features2$mzmed, pch = 16, col = seq(nrow(y.features)))
```

Therefore, the first 4 features will be grouped together as `P001`, whereas the other 4 features by now will be not assigned to any feature group, until they will be assigned to an specific feature group based on the criteria already mentioned.  

As mentioned above, by now the thresholds for both intensity and peak shape correlations are `0.7`. However, in some cases this do not work 100% but it seems that one relatively low-correlated feature should be grouped to an specific group since it seems to be a fragment of the pseudo-molecular ion of that feature group. Let's see an example:

```{r}
# load the data in negative ionization mode:
load("data/RData/IS_data_XCMS_NEG.RData")

# get the matrix of feature values:
data <- featureValues(xdata, method = "sum", value = "into")
data[is.na(data)] <- 0 # replace missing values by 0

# get the matrix with the feature definitions (i.e. the mz and rt ranges, among other information):
features <- data.frame(featureDefinitions(xdata))

# calculate the mean(intensity) of each feature according the type of sample:
features$mean_solv <- rowMeans(data[,xdata$tissue == "solv"])
features$mean_blank <- rowMeans(data[,xdata$tissue == "blank"])
features$mean_STDmix <- rowMeans(data[,xdata$tissue == "STDmix"])

# get the maximum value of mean(intensity) among the 3 sample classes:
features$mean_max <- apply(features[,c("mean_solv", "mean_blank", "mean_STDmix")], 1, max)

# order the features according the "mean_max" value in from the highest one:
features <- features[order(features$mean_max, decreasing = T), ]

# get the features particular of blank samples:
features <- features[features$npeaks == 2 & features$blank == 2 & 
                       features$solv == 0 & features$STDmix == 0, ]

y <- 13
features[y,]

# Take those features that are co-eluting with feature "y":
y.features <- features[(features$rtmed > (features$rtmed[y] - 10)) & 
                         ( features$rtmed < (features$rtmed[y] + 10)), ]
y.features[,c("mzmed", "rtmed", "mean_max")] # there are 2 features co-eluting with feature "y"

# Calculate the intensity correlation between feature "y" and these co-eluting features:
y.data <- data[rownames(data) %in% rownames(y.features), ]
y.cor <- cor(t(y.data), y.data[rownames(features)[y],])
y.features <- merge(y.features,y.cor, by = "row.names")
colnames(y.features)[ncol(y.features)] <- "corr_int"
rownames(y.features) <- y.features$Row.names
y.features <- y.features[,-1]
```

```{r, echo = FALSE}
y.features2 <- y.features
y.features2$mzmed <- sprintf("%.4f", round(y.features2$mzmed, 4))
y.features2$rtmed <- sprintf("%.2f", round(y.features2$rtmed/60, 2))
y.features2$mean_max <- round(y.features$mean_max)
y.features2$corr_int <- sprintf("%.2f", round(y.features$corr_int, 2))
library(DT)
datatable(y.features2[,c("mzmed", "rtmed", "mean_max", "corr_int")], options = list(dom = 't', pageLength = nrow(y.features2))) %>% formatStyle(columns = "corr_int", backgroundColor = styleInterval(0.7,c("#FB717E","#89EC6A")))
```

```{r}
# Calculate the peak shape correlation between feature "y" and the other selected features:
y.features <- y.features[y.features$corr_int > 0.7, ]
y.xdata <- filterFile(xdata, which.max(data[rownames(features)[y],]))
y.chr <- chromatogram(y.xdata,
                      mz = features$mzmed[y] + 0.01 * c(-1, 1),
                      rt = features$rtmed[y] + 10 * c(-1,1),
                      aggregationFun = "max")
y.cor <- c()
for(i in seq(nrow(y.features))){
  y.chr2 <- chromatogram(y.xdata,
                         mz = y.features$mzmed[i] + 0.01 * c(-1, 1),
                         rt = y.features$rtmed[i] + 10 * c(-1,1),
                         aggregationFun = "max")
  y.cor <- c(y.cor, correlate(y.chr[[1]], y.chr2[[1]]))
  names(y.cor)[length(y.cor)] <- rownames(y.features)[i]
}
y.cor[is.na(y.cor)] <- 0
y.features <- merge(y.features,y.cor, by = "row.names")
colnames(y.features)[ncol(y.features)] <- "corr_ps"
rownames(y.features) <- y.features$Row.names
y.features <- y.features[,-1]
```

```{r, echo=FALSE}
y.features2 <- y.features
y.features2$mzmed <- sprintf("%.4f", round(y.features2$mzmed, 4))
y.features2$rtmed <- sprintf("%.2f", round(y.features2$rtmed/60, 2))
y.features2$mean_max <- round(y.features$mean_max)
y.features2$corr_int <- sprintf("%.2f", round(y.features$corr_int, 2))
y.features2$corr_ps <- sprintf("%.2f", round(y.features$corr_ps, 2))
datatable(y.features2[,c("mzmed", "rtmed", "mean_max", "corr_int", "corr_ps")], options = list(dom = 't', pageLength = nrow(y.features2))) %>% formatStyle(columns = "corr_ps", backgroundColor = styleInterval(0.7,c("#FB717E","#89EC6A")))
plot(rtime(y.chr[[1]]), intensity(y.chr[[1]])/max(intensity(y.chr[[1]]), na.rm = T), type = "l", xlab = "RT", ylab = "Relative intensity")
for(i in seq(nrow(y.features))){
  y.chr2 <- chromatogram(y.xdata,
                         mz = y.features$mzmed[i] + 0.01 * c(-1, 1),
                         rt = y.features$rtmed[i] + 10 * c(-1,1),
                         aggregationFun = "max")
  points(rtime(y.chr2[[1]]), intensity(y.chr2[[1]])/max(intensity(y.chr2[[1]]), na.rm = T), type = "l", col = i)
}
legend("topright", legend = y.features2$mzmed, pch = 16, col = seq(nrow(y.features)))
```

Here we can see that the feature with the mz value 371.3825 do not have a peakshape correlation > 0.7 with the reference `feature "y"` (the one with the mz value 560.4823). However, if we check the MS2 spectra of the `feature "y"` we can see that the ion at mz 371.3825 is the main fragment of the precursor at mz 560.4823:

```{r, message=FALSE}
library(CluMSID)
load("data/RData/MS2_library_NEG.RData")
y.ms2 <- getSpectrum(ms2list, "precursor", 560.4823, mz.tol = 0.001)
y.ms2 <- getSpectrum(y.ms2, "rt", 14.58*60, rt.tol = 5)
specplot(y.ms2[[13]], main = paste(round(y.ms2[[13]]@precursor, 4), "-", round(y.ms2[[13]]@rt/60, 2)))
```

Therefore, when doing the filter of features based on peak shape correlation, I'll use the threshold of 0.7 OR a threshold of 0.5 + MS2 relationship.

## Feature grouping algorithm

Now I'll apply the feature grouping code for all the dataset (by now, checking only features particular of blank samples in order to be faster since this step is time consuming) in both polarities:

```{r, message=FALSE, eval=FALSE}
z.polarities <- c("POS", "NEG")
for(z in seq(length(z.polarities))){
  load(paste0("data/RData/IS_data_XCMS_", z.polarities[z], ".RData"))
  load(paste0("data/RData/MS2_library_", z.polarities[z], ".RData"))
  data <- featureValues(xdata, method = "sum", value = "into")
  data[is.na(data)] <- 0
  features <- data.frame(featureDefinitions(xdata))
  features$polarity <- z.polarities[z]
  features$mean_solv <- rowMeans(data[,xdata$tissue == "solv"])
  features$mean_blank <- rowMeans(data[,xdata$tissue == "blank"])
  features$mean_STDmix <- rowMeans(data[,xdata$tissue == "STDmix"])
  features$mean_max <- apply(
    features[,c("mean_solv", "mean_blank", "mean_STDmix")], 1, max)
  features <- features[order(features$mean_max, decreasing = T), ]
  features <- features[features$npeaks == 2 & features$blank == 2 & 
                         features$solv == 0 & features$STDmix == 0, ]
  features$FG <- NA
  y.n <- 0
  for(y in seq(13#nrow(features)
  )){
    if(is.na(features$FG[y])){ # continue only if feature "y" still has not 
                               # assigned to any "FG"
      y.n <- y.n + 1 
      y.features <- features[is.na(features$FG), ] # subset the feature  matrix taking only
                                                # those still have not assigned to any "FG"
      y.ft <- which(rownames(y.features) == rownames(features)[y])
      
      # RT range: get the co-eluting features
      y.features <- y.features[(y.features$rtmed > (y.features$rtmed[y.ft] - 10)) & 
                                 ( y.features$rtmed < (y.features$rtmed[y.ft] + 10)), ]
      if(nrow(y.features) > 1){
        
        # intensity correlation
        y.data <- data[rownames(data) %in% rownames(y.features), ]
        y.cor <- cor(t(y.data), y.data[rownames(features)[y],])
        y.features <- merge(y.features,y.cor, by = "row.names")
        colnames(y.features)[ncol(y.features)] <- "corr_int"
        rownames(y.features) <- y.features$Row.names
        y.features <- y.features[,-1]
        y.features <- y.features[y.features$corr_int > 0.7, ]
        
        # peak-shape correlation
        y.xdata <- filterFile(xdata, which.max(data[rownames(features)[y],]))
        y.chr <- chromatogram(y.xdata,
                              mz = features$mzmed[y] + 0.01 * c(-1, 1),
                              rt = features$rtmed[y] + 10 * c(-1,1),
                              aggregationFun = "max")
        y.cor <- c()
        for(i in seq(nrow(y.features))){
          y.chr2 <- chromatogram(y.xdata,
                                 mz = y.features$mzmed[i] + 0.01 * c(-1, 1),
                                 rt = y.features$rtmed[i] + 10 * c(-1,1),
                                 aggregationFun = "max")
          y.cor <- c(y.cor, correlate(y.chr[[1]], y.chr2[[1]]))
          names(y.cor)[length(y.cor)] <- rownames(y.features)[i]
        }
        y.cor[is.na(y.cor)] <- 0
        y.features <- merge(y.features,y.cor, by = "row.names")
        colnames(y.features)[ncol(y.features)] <- "corr_ps"
        rownames(y.features) <- y.features$Row.names
        y.features <- y.features[,-1]
        
        # MS2 associations
        y.features$MS2 <- NA
        for(i in seq(nrow(y.features))){
          y.ms2 <- findFragment(ms2list, y.features$mzmed[i])
          y.ms2 <- getSpectrum(y.ms2, "rt", y.features$rtmed[i], rt.tol = 10)
          for(j in seq(nrow(y.features))){
            if(length(y.ms2) == 1){
              tmp <- abs(y.ms2@precursor - y.features$mzmed[j]) < 0.01
            } else if(length(y.ms2) > 1){
              tmp <- length(getSpectrum(y.ms2, "precursor", 
                                        y.features$mzmed[j], mz.tol = 0.01)) > 0
            } else if(length(y.ms2) == 0){
              tmp <- FALSE
            }
            if(is.na(y.features$MS2[i])){
              y.features$MS2[i] <- tmp
            } else {
              y.features$MS2[i] <- paste0(y.features$MS2[i], "; ", tmp)
            }
            
          }
        }
        y.features$MS2 <- grepl("TRUE", y.features$MS2)
        
        y.features <- y.features[
          y.features$corr_ps > 0.7 |
            (y.features$corr_ps > 0.5 & y.features$MS2), ]  
      }
      features$FG[rownames(features) %in% rownames(y.features)] <- y.n
    }
  }
  
  
  
  features$FG <- paste0(substr(z.polarities[z], 1, 1), 
                        formatC(features$FG, width = nchar(nrow(features)), 
                                flag = "0"))
  rownames(data) <- gsub("FT", substr(z.polarities[z], 1, 1), rownames(data))
  colnames(data) <- gsub(paste0("_", z.polarities[z], "_FS.mzData"), "", colnames(data))
  rownames(features) <- gsub("FT", substr(z.polarities[z], 1, 1), rownames(features))
  if(z == 1){
    featuresz <- features
    dataz <- data
  } else if(z == 2){
    features <- rbind(featuresz, features)
    data <- rbind(dataz, data)
  }
}
```


## Group FGs between polarities

At this point, we should group features between both polarities when a compound is ionizated in both modes.   
In that case, both feature groups should present a similar RT and a high intensity correlation (peak shape correlation cannot be used in this case, since it can be different in each ionization mode). Additionally, the neutral mass of molecular ion of both feature groups should be the same, but getting this value can be quiet complex since not all compounds produce the pseudo-molecular ion in both ionization modes (i.e., sometimes we just see the ions of an specific adduct). In any case, let's go step by step using the case example already commented above.  
Now, we have all features grouped in the same data frame `features`. In this table there is a column called "polarity" that indicates if the feature comes from the positive or negative ionization mode dataset.  
Again, first of all let's order the feature matrix by intensity and start with the group of the first feature:

```{r, echo=FALSE}
load("tmp.RData")
```


```{r}
features <- features[order(features$mean_max, decreasing = T), ]
features$isotopes <- NA
y <- 1
features[y,]
```

This feature belongs to positive ionization mode dataset and feature group `P001`.   
Now, I'll select all features assigned to `P001` together with all features from negative ionization mode co-eluting with feature group `P001`.

```{r}
y.features <- features[(features$FG == features$FG[y]) | 
                         (features$polarity != features$polarity[y.ft]),]
y.features <- y.features[(y.features$rtmed > (y.features$rtmed[y.ft] - 10)) & 
                           ( y.features$rtmed < (y.features$rtmed[y.ft] + 10)), ]
y.features[,c("mzmed", "rtmed", "mean_max", "polarity", "FG")]
```

Here we can see that all features from negative ionization mode co-eluting with `P001` are grouped in a single feature group called `N12`.  
Now, let's see if they present a relatively high intensity correlation. For that I'll use the ion with the highest intensity in each ionization mode:

```{r}
cor(data[rownames(y.features)[which(y.features$polarity == "POS")[1]],],
    data[rownames(y.features)[which(y.features$polarity == "NEG")[1]],])
```


### Isotopologues 

At this point, I want to group the isotopologues in order to use only the main ion for the deduction of the neutral mass of the molecular ion.  
For that I'll have to work (again) using each ionization mode separately. Let's start with the positive mode:  

```{r, message=FALSE, warning=FALSE}
library(CompoundDb)
y.pol <- y.features[y.features$polarity == "POS", ]
i <- 1
for(j in seq(4)){
  y.pol$isotopes[
    unlist(matchWithPpm(y.pol$mzmed[i] + 1.003355*j, y.pol$mzmed, 
                        ppm = 10))] <- paste0("(",j,")13C[", 
                                              round(y.pol$mzmed[i]), "]")
}
y.pol$isotopes[
  unlist(matchWithPpm(y.pol$mzmed[i] - 1.007276, y.pol$mzmed, 
                      ppm = 10))] <- paste0("M[", 
                                            round(y.pol$mzmed[i]), "]")
if(length(grep(round(y.pol$mzmed[i]), y.pol$isotopes)) > 0){
  y.pol$isotopes[i] <- paste0("[", round(y.pol$mzmed)[i], "]")
}
y.pol[,c("mzmed", "rtmed",  "mean_max", "FG", "isotopes")]
```

```{r, echo=FALSE, message=FALSE}
load("data/RData/IS_data_XCMS_POS.RData")
y.xdata <- filterFile(xdata, which.max(data[rownames(features)[y],]))
library(MsCoreUtils)
sps <- as.data.frame(xdata[[closest(features$rtmed[y], rtime(y.xdata))]])
par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
idx <- (sps$i/max(sps$i)) > 0.1
plot(sps$mz, sps$i, type = "h", xlab = "m/z", ylab = "intensity", main = paste("RT:", round(rtime(y.xdata)[(closest(features$rtmed[y], rtime(y.xdata)))]/60, 2)))
text(sps$mz[idx], sps$i[idx], round(sps$mz[idx], 4), cex = 0.8)
par(mar = c(4, 2, 2, 1))
plot(sps$mz, sps$i, type = "h", xlab = "m/z", ylab = "intensity", xlim = c(514, 520))
idx <- unlist(matchWithPpm(y.pol$mzmed, sps$mz, ppm =10))
text(sps$mz[idx], sps$i[idx], round(sps$mz[idx], 4), cex = 0.8)
```

And now, let's check what is happening in the negative mode:

```{r}
y.pol <- y.features[y.features$polarity == "NEG", ]
i <- 1
for(j in seq(4)){
  y.pol$isotopes[
    unlist(matchWithPpm(y.pol$mzmed[i] + 1.003355*j, y.pol$mzmed, 
                        ppm = 10))] <- paste0("(",j,")13C[", 
                                              round(y.pol$mzmed[i]), "]")
}
y.pol$isotopes[
  unlist(matchWithPpm(y.pol$mzmed[i] - 1.007276, y.pol$mzmed, 
                      ppm = 10))] <- paste0("M[", 
                                            round(y.pol$mzmed[i]), "]")
if(length(grep(round(y.pol$mzmed[i]), y.pol$isotopes)) > 0){
  y.pol$isotopes[i] <- paste0("[", round(y.pol$mzmed)[i], "]")
}
y.pol[,c("mzmed", "rtmed", "mean_max", "FG", "isotopes")]
```


```{r, echo=FALSE, message=FALSE}
load("data/RData/IS_data_XCMS_NEG.RData")
y.xdata <- filterFile(xdata, which.max(data[rownames(features)[y],]))
sps <- as.data.frame(xdata[[closest(features$rtmed[y], rtime(y.xdata))]])
par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
idx <- (sps$i/max(sps$i)) > 0.1
plot(sps$mz, sps$i, type = "h", xlab = "m/z", ylab = "intensity", main = paste("RT:", round(rtime(y.xdata)[(closest(features$rtmed[y], rtime(y.xdata)))]/60, 2)))
text(sps$mz[idx], sps$i[idx], round(sps$mz[idx], 4), cex = 0.8)
par(mar = c(4, 2, 2, 1))
plot(sps$mz, sps$i, type = "h", xlab = "m/z", ylab = "intensity", xlim = c(558, 564))
idx <- unlist(matchWithPpm(y.pol$mzmed, sps$mz, ppm =10))
text(sps$mz[idx], sps$i[idx], round(sps$mz[idx], 4), cex = 0.8)
```

At this point we can see that all grouped features from positive dataset correspond to the same isotopologue, being the ion at mz 516.4916 the main one, whereas in negative dataset it seems that there are 2 isotopologues, the one from the ion at mz 560.4823 and another one at mz 371.3825.  

```{r}
features <- features[order(features$mean_max, decreasing = T), ]
features$isotopes <- NA
features$annotation <- NA
features$assignation <- NA
y <- 1
y.features <- features[!is.na(features$FG),]
y.ft <- which(rownames(y.features) == rownames(features)[y])
y.features <- y.features[(y.features$FG == y.features$FG[y.ft]) | 
                           (y.features$polarity != y.features$polarity[y.ft]),]
y.features <- y.features[(y.features$rtmed > (y.features$rtmed[y.ft] - 10)) & 
                           ( y.features$rtmed < (y.features$rtmed[y.ft] + 10)), ]
for(z in seq(length(z.polarities))){
  y.pol <- y.features[y.features$polarity == z.polarities[z], ]
  for(i in seq(nrow(y.pol))){
    if(is.na(y.pol$isotopes[i])){
      for(j in seq(4)){
        y.pol$isotopes[
          unlist(matchWithPpm(y.pol$mzmed[i] + 1.003355*j, y.pol$mzmed, 
                              ppm = 10))] <- paste0("(",j,")13C[", 
                                                    round(y.pol$mzmed[i]), "]")
      }
      y.pol$isotopes[
        unlist(matchWithPpm(y.pol$mzmed[i] - 1.007276, y.pol$mzmed, 
                            ppm = 10))] <- paste0("M[", 
                                                  round(y.pol$mzmed[i]), "]")
      if(length(grep(round(y.pol$mzmed[i]), y.pol$isotopes)) > 0){
        y.pol$isotopes[i] <- paste0("[", round(y.pol$mzmed)[i], "]")
      }
      y.pol$isotopes[is.na(y.pol$isotopes)] <- paste0("[",round(y.pol$mzmed)[is.na(y.pol$isotopes)],"]")
    }
  }
  y.features[rownames(y.pol), "isotopes"] <- y.pol[, "isotopes"]
}
tmp <- y.features[!grepl("13C|M", y.features$isotopes),]  
tmp[,c("mzmed", "rtmed", "mean_max", "FG", "isotopes")]
```

### Annotation

Calculating the differences in the mz values of these "main ions" would help to deduce which would be the neutral mass of the compound that is producing these signals:

```{r}
y.dif <- outer(tmp$mzmed[tmp$polarity == "POS"],  tmp$mzmed[tmp$polarity == "NEG"], "-")
rownames(y.dif) <- round(tmp$mzmed[tmp$polarity == "POS"], 4)
colnames(y.dif) <- round(tmp$mzmed[tmp$polarity == "NEG"], 4)
y.dif
```

In parallel, it is necessary a theoretical matrix providing the mass differences for adducts generated in both ionization modes:

```{r}
library(Rdisop)
massneg <- c(-1.007276, c(-1.007276 + getMolecule("HCOOH")$exactmass))
masspos <- c(1.007276, getMolecule("NH4")$exactmass)
massdif <- outer(masspos, massneg, "-")
colnames(massdif) <- c("[M-H]-", "[M-H+HCOOH]-")
rownames(massdif) <- c("[M+H]+", "[M+NH4]+")
massdif
```

Now, we need to check if any difference among the main ions in positive and negative modes (reported in the object `y.dif`) match within any theoretical mass difference reported in the matrix `massdif`.

```{r}
for(i in seq(nrow(y.dif))){
  for(j in seq(ncol(y.dif))){
    for(a in seq(nrow(massdif))){
      for(b in seq(nrow(massdif))){
        if(dplyr::between(y.dif[i,j], massdif[a,b] - 0.01, massdif[a,b] + 0.01)){
          tmp$annotation[rownames(y.dif)[i] == 
                           round(tmp$mzmed, 4)] <- rownames(massdif)[a]
          tmp$annotation[colnames(y.dif)[j] == 
                           round(tmp$mzmed, 4)] <- colnames(massdif)[b]
        }
      }
    }
  }
}
y.features[rownames(tmp), "annotation"] <- tmp[, "annotation"]
y.features[order(y.features$polarity, y.features$mzmed),c("mzmed", "rtmed", "mean_max", "FG", "isotopes", "annotation")]
```

Here we can see that probably the main ion of the positive isotopologue would correspond to the `[M+H]+`, whereas the main ion of the highest negative isotopologue to the `[M-H+HCOOH]-`.  


```{r}
for(z in seq(length(z.polarities))){
  y.pol <- y.features[y.features$polarity == z.polarities[z], ]
  tmp <- gsub("]", "", gsub(".*\\[", "", y.pol$isotopes))
  for(i in seq(length(levels(factor(tmp))))){
    y.pol$assignation <- gsub(paste0("\\[", levels(factor(tmp))[i],"]"), y.pol$annotation[y.pol$isotopes == paste0("[", levels(factor(tmp))[i],"]")], y.pol$isotopes)
  }
  y.features[rownames(y.pol), "assignation"] <- y.pol[, "assignation"]
}
y.features$assignation <- gsub("\\(1)13C", "13C", y.features$assignation)
y.features$assignation <- gsub("M\\[M\\+H\\]\\+", "\\[M\\]\\+", y.features$assignation)

y.features[order(y.features$polarity, y.features$mzmed),c("mzmed", "rtmed", "mean_max", "FG", "isotopes", "annotation", "assignation")]
```

We still can see that the ion at mz -371.3825 is not "well" annotated, although if we have already seen that it is a fragment of the ion at mz -560.4823. Below, I'm going to annotate these cases:

```{r, message=FALSE}
tmp <- which(!grepl("M", y.features$assignation))
if(length(tmp) > 0){
  for(i in seq(length(tmp))){
    y.pol <- y.features[y.features$polarity == y.features$polarity[tmp[i]], ] 
    load(paste0("data/RData/MS2_library_", y.features$polarity[tmp[i]], ".RData"))
    y.ms2 <- findFragment(ms2list, y.features$mzmed[tmp[i]])
    y.ms2 <- getSpectrum(y.ms2, "rt", y.features$rtmed[tmp[[i]]], rt.tol = 10)
    y.ms2.prec <- c()
    for(j in seq(length(y.ms2))){
      y.ms2.prec <- c(y.ms2.prec, y.ms2[[j]]@precursor)
    }
    y.features$assignation[tmp[[i]]] <- paste("fragment", round(y.pol$mzmed)[which.max(unlist(lapply(matchWithPpm(y.pol$mzmed, y.ms2.prec, ppm = 10), length)))])
  }
}
y.features[order(y.features$polarity, y.features$mzmed),c("mzmed", "rtmed", "mean_max", "FG", "isotopes", "annotation", "assignation")]
```


