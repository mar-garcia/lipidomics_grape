---
title: "Data analysis: maturation"
author: "Mar Garcia-Aloy"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    toc: true
    number_sections: false
    toc_float: true
---

```{r startpoint, include = FALSE}
startpoint <- Sys.time()
knitr::opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE)
nsubmod <- 1000
indep <- "date" # specify "brix" or "date"
```

This document belongs to the project of application of the new targeted lipidomics method to grape samples collected at different maturation stages.  

# Libraries

```{r libraries, warning = FALSE, message = FALSE}
library(readxl)
library(xcms)
library(plotly)
library(knitr)
library(pls)
library(pheatmap)
library(RColorBrewer)
```


# Read data

```{r import-data}
# Import compound quantification data:
data <- read_xlsx("data/data_maturation.xlsx", sheet = "loq_data")
colnames(data)[1] <- "ID"

# Create a vector specifying the sample classes:
class <- colnames(data)[-1]
class <- gsub("_Rep.*", "", class)
class <- gsub("_MIX.*", "", class)
class[grep("QC", class)] <- "QC"

# Load compound annotations:
#cmps <- read.csv("C:/Users/garciaalom/Google Drive/projectes/lipidomics_shared/compounds_target.csv")
cmps <- read.csv("data/compounds_target.csv")
cmps <- cmps[cmps$ID %in% data$ID, ]
nrow(data) == nrow(cmps) #TRUE
cmps <- cmps[match(data$ID, cmps$ID), ]

# Replace R problematic symbols in compound names:
all(cmps$ID == data$ID) # TRUE
cmps$ID <- data$ID <- gsub("[^0-9A-Za-z///' ]", "_", cmps$ID)
cmps$ID <- data$ID <- gsub("/", "_", cmps$ID)
cmps$ID <- data$ID <- gsub(" ", "_", cmps$ID)
cmps$ID <- data$ID <- gsub("__", "_", cmps$ID)
idx <- grep("_$", cmps$ID)
cmps$ID[idx] <- data$ID[idx] <- substr(cmps$ID[idx], 1, nchar(cmps$ID[idx])-1)
data <- data[,-1]
data <- sapply(data, as.numeric)
rownames(data) <- cmps$ID
rm(idx)
```

Below we import and plot the data regarding the brix degree of collected samples according to the sampling date.  

```{r brix}
brix <- readxl::read_excel("data/Grape_Brix_Datafile.xlsx")
brix <- brix[order(brix$data, brix$Replicate), ]
plot(as.Date(brix$data), brix$Brix, 
     col = brix$Replicate + 1, pch = 16, xlab = "Date", ylab = "Brix")
legend("bottomright", legend = paste("Rep ", seq(5)), col = 2:6, pch = 16)
```



# Identify and remove problematic compounds

The dataset contains information about the quantification of n=`r nrow(data)` compounds in n=`r ncol(data)` samples of the following classes: `r paste0(aggregate(class, list(class), function(x){sum(class == x)})[,1], " (n=", aggregate(class, list(class), function(x){sum(class == x)})[,2], ")", collapse = "; ")`. 

Missing values (n=`r sum(is.na(data))`) in the dataset will be replaced by a random value between 0 and the half the smallest measured concentration for the corresponding compound

## Quality control samples

We check (and, if any, list) if there are compounds not detected in all QC samples:

```{r qc}
idx <- which(rowSums(is.na(data[, class == "QC"])) == length(which(class == "QC")))
tmp <- data[idx, class == "QC"]
rownames(tmp) <- rownames(data)[idx]
kable(tmp)
length(idx) # n° compounds with missing values in ALL QC samples
length(which(rowSums(is.na(
  data[, class == "QC"])) > 0)) # n° compounds not detected in ALL QC samples
```

Next we calculate the CV across QC samples to check the quality of acquired data and their distribution is plotted below:

```{r qc-cv}
CV <- function(x){(sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE))*100}
CV_QC <- apply(data[, class == "QC"], 1, CV)
plot(density(CV_QC, na.rm = TRUE), xlab = "CV (%)", main = "")
```

The CV is around or below 10% for most of the compounds, but some have a higher CV.  
The following table shows the the amount of compounds with specific CV intervals:  

```{r qc-cv-table}
kable(table(cut(CV_QC, c(0, 10, 20, 30, 50, 80, max(CV_QC, na.rm = T)))))
range(CV_QC, na.rm = TRUE)
```

Below it is plotted the distribution within QC samples of the 4 compounds with the highest CV in QCs:

```{r qc-cv-plot, fig.height = 7}
par(mfrow = c(2, 2))
idx <- order(CV_QC, decreasing = T)[1:4]
for(i in seq(4)){
  plot(data[idx[i], class == "QC"], xlab = "", ylab = "", pch = 16, 
       main = paste0(rownames(data)[idx][i], " (CV=", round(CV_QC[idx[i]]), "%)"))
}
rm(tmp, CV, idx, i)
```

<span style="color:red">**We still have to decide if to exclude some compounds based what it has been observed within QC samples.**</span>  


In the table below there are listed the compounds with the highest CV in QC samples togheter with the number of QC and study samples WITHOUT any quantification value for the respective compound (i.e, <LOQ or <LOD).

```{r}
dt <- data.frame(
  CV_QC = CV_QC,
  NA_QC = rowSums(is.na(data[, class == "QC"])),
  NA_study = rowSums(is.na(data[, class != "QC"]))
)
dt <- dt[order(dt$CV_QC, decreasing = T),]
head(dt, 20)
rm(CV_QC, dt)
```



## Study samples

Below we are going to check how many variables have X missing values among the samples.

```{r}
na_n <- apply(data, 1, function(x) length(which(is.na(x))))
table(na_n)

na_n <- aggregate(t(data), by=list(class), function(x){sum(!is.na(x))})
na_n <- apply(na_n[,-1], 2, max)
head(na_n[order(na_n)], 20)
```

There are n=`r sum(na_n == 0)` compounds (`r names(which(na_n == 0))`) that have `NA` values for all study samples. These compounds are excluded from the dataset.  
Additionally, there are n=`r sum(na_n == 1 | na_n == 2)` compounds (`r names(which(na_n == 1 | na_n == 2))`) that, although they were detected in >=1 sample, they have only been detected at maximum in 1 or 2 samples within a same class. These compounds are also excluded from the dataset.      

```{r}
cmps <- cmps[cmps$ID %in% rownames(data)[na_n > 2], ]
data <- data[na_n > 2, ]
rownames(data) <- cmps$ID
rm(na_n)
```


## IS

Below we exclude `IS` compounds.

```{r filter-data}
IS <- c("15:0-18:1-D7-PA", "15:0-18:1(d7) DAG_Na", "15:0-18:1(d7) PC", 
        "15:0-18:1(d7) PE", "15:0-18:1(d7) PG", "15:0-18:1(d7) PI", 
        "15:0-18:1(d7) PS", "15:0-18:1(d7)-15:0 TAG_Na", "17:0 Lyso PA",
        "17:1 Lyso PG", "17:1 Lyso PI", "17:1 Lyso PS", "18:1(d7) Chol Ester",
        "18:1(d7) Lyso PC", "18:1(d7) Lyso PE", "18:1(d7) MAG", "24:0 (d4) carnitine",
        "C15 Ceramide-d7", "d18:1-18:1(d9) SM", "Hydrog DGDG (18:0-18:0)",
        "Hydrog MGDG (18:0-16:0)", "stearic_acid_D3")
IS <- gsub("[^0-9A-Za-z///' ]", "_", IS)
IS <- gsub("/", "_", IS)
IS <- gsub(" ", "_", IS)
IS <- gsub("__", "_", IS)
idx <- grep("_$", IS)
IS[idx] <- substr(IS[idx], 1, nchar(IS[idx])-1)
IS <- gsub("_Na", "", IS)
data <- data[!rownames(data) %in% IS,]

cmps <- cmps[!cmps$ID %in% IS,]
```


The filtered dataset contains information about the quantification of n=`r nrow(data)` compounds in n=`r ncol(data)` samples.


# PCA

We start with an exploratory analysis of the data through a principal component analysis (PCA) on log-transformed and Pareto-scaled abundances.  


```{r pca-score}
scaling.pareto <- BioMark::scalefun(sc.p="pareto")
set.seed(123)
dt <- t(imputeRowMinRand(as.matrix(data), method = "from_to",
                         min_fraction = 1/2,
                         min_fraction_from = 0))
dt <- log10(dt)
dt <- data.frame(scaling.pareto(dt))
pca <- prcomp(dt, center = FALSE, scale. = FALSE)
tmp <- data.frame(pca$x)
plot_ly(x = tmp$PC1, y = tmp$PC2,
        text = rownames(tmp),
        color = class)
```

`QC` samples are clustered together close to the origin of the scores plot. They show a lower dispersion between them compared to that observed among the study samples and also among the samples from the same study group (i.e., time-point), indicating a good analytical reproducibility (i.e., the variability due to the analytical platform is smaller than the biological/technical variability between the samples, either the ones collected at the same moment).  

Visual inspection of the PCA score shows a certain degree of separation between the first and second half of samples along the first two components (accounting for `r round(summary(pca)$importance[2,1]*100, 1)`% and `r round(summary(pca)$importance[2,2]*100, 1)`% of the total variance explained, respectively).  
To visualize this more clearly, the samples below are colored according to whether they belong to the first or the second half of sampling:

```{r}
class2 <- class
class2[class2 %in% c("Pt_01", "Pt_02", "Pt_03", "Pt_04", "Pt_05", 
                     "Pt_06")] <- "Pt_01_06"
class2[class2 %in% c("Pt_07", "Pt_08", "Pt_09", "Pt_10", "Pt_11", 
                     "Pt_12", "Pt_13")] <- "Pt_07_13"
plot_ly(x = tmp$PC1, y = tmp$PC2,
        text = rownames(tmp),
        color = class2)
```


```{r pca-loading}
all(cmps$ID == rownames(data)) # TRUE
tmp <- data.frame(pca$rotation)
plot_ly(x = tmp$PC1, y = tmp$PC2,
        text = rownames(tmp),
        color = cmps$class)
rm(tmp, dt, class2, idx, IS, scaling.pareto, pca)
```

# Associations of brix degree / date with the lipidomic profile of samples

## Data preparation

Below we exclude QC and MIX samples

```{r}
class <- class[!grepl("QC|MIX", colnames(data))]
data <- data[, !grepl("QC|MIX", colnames(data))]

write.csv(data, "stats_maturation.csv")
```

The filtered dataset contains information about the quantification of n=`r nrow(data)` compounds in n=`r ncol(data)` samples.

## PLS

First of all we fit a model with all samples.

```{r}
set.seed(123)
dt <- t(imputeRowMinRand(as.matrix(data), method = "from_to",
                         min_fraction = 1/2,
                         min_fraction_from = 0))
dt <- data.frame(log10(dt))
if(indep == "brix"){
  set.seed(123)
  model <- plsr(brix$Brix ~ ., data = dt, scale = TRUE, center = TRUE, 
                validation = "CV", ncomp = 10)
} else if(indep == "date"){
  xtime <- as.integer(as.Date(brix$data))
  set.seed(123)
  model <- plsr(xtime ~ ., data = dt, scale = TRUE, center = TRUE, 
                validation = "CV", ncomp = 10)
}
summary(model)
validationplot(model)
validationplot(model, val.type = "R2")
selectNcomp(model, plot = TRUE)
```

`r if(indep == "brix"){"The algorithm suggests that the best number of components is 2."}`  
`r if(indep == "date"){"The algorithm suggests that the best number of components is 4."}`  

```{r}
if(indep == "brix"){
  plot(model, ncomp = 2, line = T)
} else if(indep == "date"){
  plot(model, ncomp = 4, line = T)
}
```


`r if(indep == "brix"){paste0("The correlation between measured and predicted brix degree is ", sprintf("%.3f", cor(brix$Brix, predict(model, dt, ncomp = 2))))}`  

`r if(indep == "date"){paste0("The correlation between real and predicted date is ", sprintf("%.3f", cor(xtime, predict(model, dt, ncomp = 4))))}`  


## Validation

In order to verify that the model is not overfitted, below we are going to repeat the procedure, but this time building the model with 2/3 of the samples and predicting the brix / date values with the other 1/3 of samples. Assignation of samples to train or test set is doing randomly and the process is repeated `r nsubmod` times. We will check the distribution on the optimal number of components and R2 values along all generated models.

```{r, fig.width = 4}
all(rownames(data) == cmps$ID) # TRUE

N.vals <- c()
R2.vals <- c()
R2.rndm <- c()
set.seed(123)
seeds <- sample(seq(1e6), nsubmod, replace = FALSE)
set.seed(456)
rndm <- sample(seq(1e6), nsubmod, replace = FALSE)
for(i in seq(length(seeds))){
  set.seed(seeds[i])
  idx <- sample(seq(nrow(dt)), 40, replace = FALSE)
  if(indep == "brix"){
    set.seed(rndm[i])
    x.rndm <- brix$Brix[sample(seq(length(brix$Brix)), 
                               length(brix$Brix), replace = FALSE)]
    dt_train <- cbind(brix = brix$Brix[idx], dt[idx,])
    dt_test <- cbind(brix = brix$Brix[!seq(nrow(dt)) %in% idx],
                     dt[!seq(nrow(dt)) %in% idx,])
    dt_train_r <- cbind(brix = x.rndm[idx], dt[idx,])
    dt_test_r <- cbind(brix = x.rndm[!seq(nrow(dt)) %in% idx],
                       dt[!seq(nrow(dt)) %in% idx,])
    mdl <- plsr(brix ~ ., data = dt_train, scale = TRUE, center = TRUE, 
                validation = "CV", ncomp = 10)
    mdl_r <- plsr(brix ~ ., data = dt_train_r, scale = TRUE, center = TRUE, 
                  validation = "CV", ncomp = 10)
  }else if(indep == "date"){
    x.rndm <- xtime[sample(seq(length(xtime)), length(xtime), replace = FALSE)]
    dt_train <- cbind(date = xtime[idx], dt[idx,])
    dt_test <- cbind(date = xtime[!seq(nrow(dt)) %in% idx],
                     dt[!seq(nrow(dt)) %in% idx,])
    dt_train_r <- cbind(date = x.rndm[idx], dt[idx,])
    dt_test_r <- cbind(date = x.rndm[!seq(nrow(dt)) %in% idx],
                       dt[!seq(nrow(dt)) %in% idx,])
    mdl <- plsr(date ~ ., data = dt_train, scale = TRUE, center = TRUE, 
                validation = "CV", ncomp = 10)
    mdl_r <- plsr(date ~ ., data = dt_train_r, scale = TRUE, center = TRUE, 
                  validation = "CV", ncomp = 10)
  }
  N.vals <- c(N.vals, selectNcomp(mdl))
  R2.vals <- c(R2.vals, 
               R2(mdl, estimate = "test", newdata = dt_test
               )$val[selectNcomp(mdl)+1])
  
  R2.rndm <- c(R2.rndm, 
               R2(mdl_r, estimate = "test", newdata = dt_test_r
               )$val[selectNcomp(mdl_r)+1])
}
barplot(table(N.vals))
table(N.vals)
prop.table(table(N.vals))*100

boxplot(c(R2.vals, R2.rndm) ~ c(rep(1, nsubmod), rep(2, nsubmod)), 
        col = "white", ylim = c(-1, 1), ylab = "R2", xlab = "", xaxt = "n", 
        outline = FALSE)
axis(1, at = seq(2), labels = c("true Y", "random Y"))
stripchart(c(R2.vals, R2.rndm) ~ c(rep(1, nsubmod), rep(2, nsubmod)),     
           method = "jitter", vertical = TRUE, add = TRUE,
           pch = 19, col = c(4, "grey"), cex = 0.4)
```

R2 values of the generated sub-models have a median value `r sprintf("%.3f", median(R2.vals))`, a considerably higher value than the one obtained with the random models (median `r sprintf("%.3f", median(R2.rndm))`).


# Associated classes of compounds with brix degree / date

To get a general overview of which types of compounds are associated with the brix degree / date, we check the distribution of regression coefficients in the model built with all experimental data according to compound class, considering that those classes with a higher proportion in the first quartile will be those compounds with a decreasing behaviour over maturation process, whereas those compound classes with higher proportions in the fourth quartile will be those compounds with a direct association with the brix degree / date (i.e., maturation process).

```{r}
col_class_cmps <- c(
  Lyso_PC = "#E41A1C", DAG = "#974661", PG = "#4A72A6", 
  Lyso_PG = "#3E8E93", PC = "#48A462", MGDG = "#5D995D", Lyso_PA = "#7E6E85", 
  Lyso_PI = "#A35390", PS = "#D16948", PE = "#FF7F00", DGDG = "#FFB716", 
  CAR = "#FFF02D", MAG = "#E1C62F", CER = "#B97B2A", FFA = "#B75F49", 
  Lyso_PE = "#DB728C", PI = "#EC83BA", PA = "#C28EA9", TAG = "#999999")


tmp <- data.frame(
  RC = coef(model, ncomp = 2),
  class = cmps$class
)
colnames(tmp)[1] <- "RC"
tmp$quantile <- dplyr::ntile(tmp$RC, 4)

table(tmp$class, tmp$quantile)
tmp2 <- prop.table(table(tmp$class, tmp$quantile), 1)*100
tmp2

tmp2 <- cbind(tmp2[,1],
              tmp2[, 2] + tmp2[,3],
              tmp2[, 4])
colnames(tmp2) <- c("Q1", "Q2-Q3", "Q4")
```

The following heatmap shows the quartile distribution of regression coefficients by compound class. Since the clases of interest will be the ones with higher proportion of compunds in the first and fourth quartile, we have grouped together Q2 and Q3. Proportions of compounds in different quartiles are depicted with a color scale where red represents the categories with higher proportions and blue represents the lowest ones.

```{r}
pheatmap(tmp2, cluster_cols = F, cutree_rows = 3)
```

**When using `brix degree` as independent variable:**
Heatmap clearly shows that there is a group of compound classes (`CAR`, `FFA`, `TAG`, `MAG`, `DAG` and `PS`) for which most of compounds do not have a strong regression coefficient, that is, in general do not seem to be sensitive to ripening.  
On the other hand, we can see two other row clusters: one with those compound classes with higher proportions within the Q1 and the other one with those compound classes with higher proportions within the Q4. Among these, we could say that classes `CER`, `Lyso_PI` and `Lyso_PG` seems to be the ones with higher proportions of specific compounds inversely related with brix degree (i.e., in general, their levels drop as brix increases), whereas `PE`, `PG` and `Lyso_PE` would be the ones with higher proportion of specific compounds directly related with brix degree.  
Below we plot the behaviour of specific compounds of mentioned classes. Color scale is proportional to the corresponding regression coefficient.

```{r}
plt.cls <- function(cls, clr, dcrs){
  idx <- which(cmps$class == cls)
  pal <- colorRampPalette(brewer.pal(9, clr))
  i <- 1
  j <- order(tmp$RC[idx], decreasing = dcrs)[i]
  if(indep == "brix"){
    plot(brix$Brix, scale(dt[,cmps$ID[idx][j]]), xlab = "Brix", ylab = "", 
         main = cls, col = pal(length(idx))[i], bty = "l", 
         ylim = c(min(scale(dt[,cmps$ID[idx]])), max(scale(dt[,cmps$ID[idx]]))))
    abline(lm(scale(dt[,cmps$ID[idx][j]])~brix$Brix), col = pal(length(idx))[i])
    for(i in 2:length(idx)){
      j <- order(tmp$RC[idx], decreasing = dcrs)[i]
      points(brix$Brix, scale(dt[,cmps$ID[idx][j]]), col = pal(length(idx))[i])
      abline(lm(scale(dt[,cmps$ID[idx][j]])~brix$Brix), col = pal(length(idx))[i])
    }
  } else if(indep == "date"){
    plot(xtime, scale(dt[,cmps$ID[idx][j]]), xlab = "Brix", ylab = "", 
         main = cls, col = pal(length(idx))[i], bty = "l", 
         ylim = c(min(scale(dt[,cmps$ID[idx]])), max(scale(dt[,cmps$ID[idx]]))))
    abline(lm(scale(dt[,cmps$ID[idx][j]])~xtime), col = pal(length(idx))[i])
    for(i in 2:length(idx)){
      j <- order(tmp$RC[idx], decreasing = dcrs)[i]
      points(xtime, scale(dt[,cmps$ID[idx][j]]), col = pal(length(idx))[i])
      abline(lm(scale(dt[,cmps$ID[idx][j]])~xtime), col = pal(length(idx))[i])
    }
  }
}
par(mfrow = c(2, 3), mar = c(2, 2, 1, 0.5))
if(indep == "brix"){
  plt.cls(cls = "CER", clr = "Greens", dcrs = T)
  plt.cls(cls = "Lyso_PI", clr = "Greens", dcrs = T)
  plt.cls(cls = "Lyso_PG", clr = "Greens", dcrs = T)
  plt.cls(cls = "PG", clr = "Reds", dcrs = F)
  plt.cls(cls = "Lyso_PE", clr = "Reds", dcrs = F)
  plt.cls(cls = "PE", clr = "Reds", dcrs = F)
} else if(indep == "date"){
  plt.cls(cls = "Lyso_PG", clr = "Greens", dcrs = T)
  plt.cls(cls = "PA", clr = "Greens", dcrs = T)
  plt.cls(cls = "PS", clr = "Greens", dcrs = T)
  plt.cls(cls = "Lyso_PE", clr = "Reds", dcrs = F)
  plt.cls(cls = "Lyso_PC", clr = "Reds", dcrs = F)
  plt.cls(cls = "PE", clr = "Reds", dcrs = F)
}
```


# Session information

```{r session}
Sys.time()-startpoint
devtools::session_info()
```
