---
title: "Times series clustering (selected combinations)"
author: "Mar Garcia-Aloy"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    toc: false
    number_sections: false
    toc_float: false
---

```{r startpoint, include = FALSE}
startpoint <- Sys.time()
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

In the previous [document](https://github.com/mar-garcia/lipidomics/blob/main/target/times_series_clustering.Rmd) I've applied the different available algorithms in the package [`TSdist`](https://journal.r-project.org/archive/2016/RJ-2016-058/RJ-2016-058.pdf) for both distance measurements and time-series clustering. Since executing that code has taken around 8 hours, I've saved the output in a table, which I'll import now in order to select the combinations with the best performance.  
  
  First of all, I load the necessary libraries, import the study data, generate the GAM models, select the discriminant compounds and generate a new data matrix with the predicted values obtained by the GAM models.

```{r}
# Load the packages
library(readxl)
library(xcms)
library(mgcv)
library(TSdist)
library(reshape2)

# Data import
brix <- readxl::read_excel("data/Grape_Brix_Datafile.xlsx")
brix <- rbind(
  brix, 
  c(2019, "diradamento", "corno - az. Oliva", "2019-09-17", "C", 0, 
    mean(brix$Brix[brix$data == "2019-09-17"])),
  c(2019, "diradamento", "corno - az. Oliva", "2019-09-24", "C", 0, 
    mean(brix$Brix[brix$data == "2019-09-24"])))
brix <- brix[order(brix$data, brix$Replicate), ]
xtime <- as.integer(as.Date(brix$data))

data <- read_xlsx("data/data_maturation.xlsx", sheet = "trans_data")
colnames(data)[1] <- "ID"
fl <- "C:/Users/garciaalom/Google Drive/projectes/lipidomics_shared/new_rt.xlsx"
cmps <- rbind(read_xlsx(fl, sheet = "IS")[, 1:2],
              read_xlsx(fl, sheet = "FORMULE")[, 1:2])
cmps$ID <- gsub("_Na", "", cmps$ID)
cmps <- cmps[cmps$ID %in% data$ID, ]
cmps <- cmps[match(data$ID, cmps$ID), ]
cmps$ID <- data$ID <- gsub("[^0-9A-Za-z///' ]", "_", cmps$ID)
cmps$ID <- data$ID <- gsub("/", "_", cmps$ID)
cmps$ID <- data$ID <- gsub(" ", "_", cmps$ID)
cmps$ID <- data$ID <- gsub("__", "_", cmps$ID)
idx <- grep("_$", cmps$ID)
cmps$ID[idx] <- data$ID[idx] <- substr(cmps$ID[idx], 1, 
                                       nchar(cmps$ID[idx])-1)
data <- data[,-1]
data <- sapply(data, as.numeric)
rownames(data) <- cmps$ID

# GAM models
data <- data[!rownames(data) %in% cmps$ID[cmps$class == "IS"], 
             !grepl("QC", colnames(data))]
set.seed(123)
dt <- t(imputeRowMinRand(as.matrix(data), method = "from_to",
                         min_fraction = 1/100,
                         min_fraction_from = 1/1000))
stat.gam <- function(x){
  as.numeric(unlist(summary(
    gam(log10(x) ~ s(xtime), method = "REML", gamma = 1.4)
  ))["s.table4"])
}
pval <- apply(FUN = stat.gam, MARGIN = 2, X = dt)
padj <- p.adjust(pval, "BH")
stat.dev <- function(x){
  summary(gam(log10(x) ~ s(xtime), method = "REML", gamma = 1.4))$dev.expl 
}
dev <- apply(FUN = stat.dev, MARGIN = 2, X = dt)

# Select discriminant compounds
dt <- dt[, padj < 0.05 & dev > 0.7]

# Calculate predictive values
ytimes <- seq(min(xtime), max(xtime))
dt_pred <- matrix(NA, nrow = length(ytimes), ncol = ncol(dt))
colnames(dt_pred) <- colnames(dt)
for(i in seq(ncol(dt_pred))){
  dt_pred[,i] <- predict.gam(
    gam(log10(dt[,i]) ~ s(xtime), method = "REML", gamma = 1.4), 
    data.frame(xtime = ytimes))  
}
dt_pred_sc <- scale(dt_pred)
dt_pred_sc_t <- t(dt_pred_sc)
```


Below, I import the table generated in the previous [code](https://github.com/mar-garcia/lipidomics/blob/main/target/times_series_clustering.Rmd) and select those combinations with the best performances.  
Performance is measured by calculating a new GAM *prototype* model for all compounds included in the same cluster and then extracting the corresponding proportion of the null deviance explained by the *prototype* model.
The table includes the following information:  
  
  - `distance_measurement`: algorithm used to compute the distance matrix from the time series data.  
  - `cluster_algorithm`: algorithm used to calculate the distance measures that are used to produce the clustering result.  
  - `cluster_n`: number of clusters generated.  
  - `cl_min_n`: number of samples included in the smallest cluster.  
  - `cl_max_n`: number of samples included in the most populated cluster.  
  - `dev_min`: minimum deviance along the different *prototype* models.  
  - `dev_max`: maximum deviance along the different *prototype* models.  
  - `dev_mean`: mean of all deviances obtained for each *prototype* model.  

```{r}
# Distance + clusters
tb <- read.csv("tsclust_tb_tmp.csv")[,-1]
tb <- tb[tb$dev_min > 0.9 & tb$dev_mean > 0.9, ]
tb <- tb[tb$cluster_n == 6, ]
tb <- tb[tb$cl_min_n > 2, ]
DT::datatable(tb)
```

Finally, for each selected combination it is plotted the behaviors of each compound colorated according to the cluster they were assigned. 

```{r}
for(k in seq(nrow(tb))){
  if(tb$distance_measurement[k] == "tquest"){
    dt_pred_dist <- TSdist::TSDatabaseDistances(
      dt_pred_sc_t, distance = "tquest", 
      tau = mean(dt_pred_sc_t), diag = T, upper = T)
  } else if(tb$distance_measurement[k] %in% c("ar.lpc.ceps", "ar.pic", "cdm", "ncd", 
                                              "spec.glk", "spec.isd", "spec.llr", "frechet")){
    dt_pred_dist <- TSdist::TSDatabaseDistances(
      dt_pred_sc_t, distance = tb$distance_measurement[k])
  } else {
    dt_pred_dist <- TSdist::TSDatabaseDistances(
      dt_pred_sc_t, distance = tb$distance_measurement[k], diag = T, upper = T)
  }
  print(paste("Distance measurement:", tb$distance_measurement[k], 
              "- Clustering algorithm:", tb$cluster_algorithm[k],
              " - n=", tb$cluster_n[k], "clusters"))
  if(tb$distance_measurement[k] == "ar.mah"){
    if(tb$cluster_algorithm[k] == "tquest"){
      cl <- KMedoids(as.matrix(dt_pred_dist[[1]]), tb$cluster_n[k], "tquest", tau = 0)
    } else {
      cl <- KMedoids(as.matrix(dt_pred_dist[[1]]), tb$cluster_n[k], tb$cluster_algorithm[k])
    }
  } else{
    if(tb$cluster_algorithm[k] == "tquest"){
      cl <- KMedoids(as.matrix(dt_pred_dist), tb$cluster_n[k], "tquest", tau = 0)
    } else {
      cl <- KMedoids(as.matrix(dt_pred_dist), tb$cluster_n[k], tb$cluster_algorithm[k])
    }
  }
  
  j <- i <- 1
  par(mfrow = c(1, 1))
  plot(ytimes, dt_pred_sc[,which(cl == j)[i]], pch = 16, col = j, 
       ylim = c(min(c(dt_pred_sc, dt_pred_sc)), 
                max(c(dt_pred_sc, dt_pred_sc))), type = "l")
  for(i in 2:length(which(cl == j))){
    points(ytimes, dt_pred_sc[,which(cl == j)[i]], col = j, pch = 16, 
           type = "l")
  }
  for(j in 2:tb$cluster_n[k]){
    for(i in 1:length(which(cl == j))){
      points(ytimes, dt_pred_sc[,which(cl == j)[i]], col = j, pch = 16, 
             type = "l")
    }
  }
  legend("topright", legend = paste0("c", seq(tb$cluster_n[k])), pch = 16, 
         col = seq(tb$cluster_n[k]), ncol = 2)
  
  dev_j <- c()
  cl_n <- c()
  par(mfrow = c(1, 2))
  for(j in 1:tb$cluster_n[k]){
    cl_n <- c(cl_n, length(which(cl == j)))
    dt_j <- data.frame(dt_pred_sc[,which(cl == j)])
    dt_j$time <- ytimes
    dt_j <- melt(dt_j, id.vars = "time")
    dev_j <- c(dev_j, summary(
      gam(dt_j$value ~ s(dt_j$time), 
          method = "REML", gamma = 1.4))$dev.expl)
    
    i <- 1
    plot(ytimes, dt_pred_sc[,which(cl == j)[i]], pch = 16, col = j, 
         ylim = c(min(c(dt_pred_sc, dt_pred_sc)), 
                  max(c(dt_pred_sc, dt_pred_sc))), type = "l", 
         main = paste0("c", j), xlab = "", ylab = "",
         sub = paste("dev = ", round(dev_j[j] , 3)))
    for(i in 2:length(which(cl == j))){
      points(ytimes, dt_pred_sc[,which(cl == j)[i]], col = j, pch = 16, 
             type = "l")
    }
  }
}
```


# Session information

```{r session}
Sys.time()-startpoint
devtools::session_info()
```